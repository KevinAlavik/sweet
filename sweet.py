#!/bin/env python3
import sys
import os
import subprocess
import random
import string

from core.lexer import Lexer, LexerError
from core.parser import Parser, ParserError

class CompileContext:
    def __init__(self):
        self.stack_depth = 0
        self.stack_is_string = []

    def new_label(self):
        return ''.join(random.choices(string.ascii_letters + string.digits, k=10))

    def add_string(self, value):
        label = f"str_{self.new_label()}"
        if not hasattr(self, "strings"):
            self.strings = []
        self.strings.append((label, value))
        return label

def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <source file>")
        sys.exit(1)

    input_file = sys.argv[1]
    output_dir = ".build"
    os.makedirs(output_dir, exist_ok=True)
    asm_file = os.path.join(output_dir, "raw.asm")
    obj_file = os.path.join(output_dir, "raw.o")
    runtime_obj = os.path.join(output_dir, "runtime.o")
    executable = sys.argv[1].replace('.sw', '') if input_file.endswith('.sw') else sys.argv[1] + ".out"

    with open(input_file, 'r') as f:
        src = f.read()

    try:
        lexer = Lexer(src)
        parser = Parser(lexer)
        ast = parser.parse()
        ctx = CompileContext()

        with open(asm_file, 'w') as out:
            out.write(";============================================================;\n")
            out.write("; Generated by Sweet v1.0 Compiler for x86_64 Linux (amd64)  ;\n")
            out.write(";============================================================;\n")
            out.write("section .text\n")
            out.write("extern print_int\n")
            out.write("extern print_str\n")
            out.write("global sweet_main\n")
            out.write("sweet_main:\n")
            for stmt in ast:
                out.write('\n'.join(stmt.compile(ctx)) + '\n')
            if ctx.stack_depth > 0:
                out.write(f"    ; Cleanup stack ({ctx.stack_depth} leftover)\n")
                out.write("    " + "\n    ".join(["pop rax"] * ctx.stack_depth) + "\n")
            out.write("    ret\n")
            out.write("section .data\n")
            if hasattr(ctx, "strings"):
                for label, value in ctx.strings:
                    raw_bytes = value.encode('utf-8').decode('unicode_escape').encode('latin1')
                    byte_values = ', '.join(str(b) for b in raw_bytes)
                    out.write(f"{label}: db {byte_values}\n")


        print(f"[+] Assembly written to {asm_file}")
        subprocess.run(["nasm", "-f", "elf64", asm_file, "-o", obj_file], check=True)
        print(f"[+] Assembled to {obj_file}")
        subprocess.run(["gcc", "-c", "runtime.c", "-o", runtime_obj], check=True)
        print(f"[+] Compiled runtime.c to {runtime_obj}")
        subprocess.run(["gcc", obj_file, runtime_obj, "-no-pie", "-o", executable], check=True)
        print(f"[âœ“] Linked into executable: {executable}")

    except (LexerError, ParserError) as e:
        print(f"[!] Error: {e}")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"[!] Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
