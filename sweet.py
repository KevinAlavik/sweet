#!/bin/env python3
import sys
import os
import subprocess
import random
import string
import argparse
import shutil

from core.lexer import Lexer, LexerError
from core.parser import Parser, ParserError

class CompileContext:
    def __init__(self):
        self.stack_depth = 0
        self.stack_types = []
        self.known_externs = {}
        self.known_vars = []

    def new_label(self):
        return "sw" + "".join(random.choices(string.ascii_letters + string.digits, k=10))
    
    def add_string(self, value):
        label = self.new_label()
        if not hasattr(self, "strings"):
            self.strings = []
        self.strings.append((label, value))
        return label
    
def gen_asm(out, ast, ctx):
    out.write(";============================================================;\n")
    out.write("; Generated by Sweet v1.0 Compiler for x86_64 Linux (amd64)  ;\n")
    out.write(";============================================================;\n")
    out.write("section .text\n")
    out.write(";---------- External symbols defined by runtime (libsw) ----------;\n")
    out.write("extern print_int\n")
    out.write("extern print_str\n")
    out.write("extern compare_int\n")
    out.write("extern compare_str\n")
    out.write("extern stdin_getline\n")
    out.write("extern new\n")
    out.write(";---------- External symbols defined by user ----------;\n")
    for stmt in ast:
        if type(stmt).__name__ == "Extern":
            out.write("\n".join(stmt.compile(ctx)) + "\n")
    out.write(";---------- Sweet Program Entry ----------;\n")
    out.write("global sweet_main\n")
    out.write("sweet_main:\n")
    for stmt in ast:
        if type(stmt).__name__ == "Extern":
            continue
        out.write(f"    ; {type(stmt).__name__}\n")
        out.write("\n".join(stmt.compile(ctx)) + "\n")
    if ctx.stack_depth > 0:
        out.write(f"    ; Cleanup stack ({ctx.stack_depth} leftover)\n")
        out.write("    " + "\n    ".join(["pop rax"] * ctx.stack_depth) + "\n")
    out.write("    ret\n")
    out.write("section .data\n")
    if hasattr(ctx, "strings"):
        for label, value in ctx.strings:
            raw_bytes = value.encode("utf-8").decode("unicode_escape").encode("latin1")
            byte_values = ", ".join(str(b) for b in raw_bytes)
            out.write(f"{label}: db {byte_values}, 0\n")
    if hasattr(ctx, "vars"):
        out.write("\nsection .bss\n")
        for name, label in ctx.vars.items():
            out.write(f"{label}: resb {ctx.var_sizes[name]}\n")


def main():
    parser = argparse.ArgumentParser(description="Sweet v1.0 Compiler for x86_64 Linux (amd64)")

    parser.add_argument("source", help="Source file (.sw)")
    parser.add_argument("-o", "--output", help="Output executable name")
    parser.add_argument("-of", "--output-format", choices=["bin", "asm", "ast", "lexer"], default="bin",
                        help="Output format: bin (default), asm (stdout), ast (stdout), lexer (stdout)")
    parser.add_argument("--cflags", default="", help="Additional C compiler flags")
    parser.add_argument("--ldflags", default="", help="Additional linker flags")
    parser.add_argument("--asflags", default="", help="Additional NASM flags")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    parser.add_argument("-r", "--run", action="store_true", help="Run the output binary after compilation, then remove it")
    parser.add_argument("-nc", "--no-clean", action="store_true", help="Remove the build directory after compilation")

    args = parser.parse_args()

    input_file = args.source

    try:
        with open(input_file, "r") as f:
            src = f.read()

        ctx = CompileContext()
        lexer = Lexer(src)

        if args.output_format == "lexer":
            tokens = lexer.lex()
            for token in tokens:
                print(token)
            return

        parser_obj = Parser(lexer, ctx)
        ast = parser_obj.parse()

        if args.output_format == "ast":
            def print_ast(node, indent=0):
                if isinstance(node, list):
                    for n in node:
                        print_ast(n, indent)
                else:
                    print(" " * indent + str(node))

            print_ast(ast)
            return


        if args.output_format == "asm":
            out = sys.stdout
            gen_asm(out, ast, ctx)
            return

        output_dir = ".build"
        os.makedirs(output_dir, exist_ok=True)

        asm_file = os.path.join(output_dir, "raw.asm")
        obj_file = os.path.join(output_dir, "raw.o")
        runtime_obj = os.path.join(output_dir, "runtime.o")

        if args.output:
            executable = args.output
        else:
            executable = "out"

        with open(asm_file, "w") as out:
            gen_asm(out, ast, ctx)

        if args.verbose:
            print(f"[+] Assembly written to {asm_file}")

        asflags = args.asflags.split() if args.asflags else []
        subprocess.run(["nasm", "-f", "elf64", asm_file, "-o", obj_file] + asflags, check=True)
        if args.verbose:
            print(f"[+] Assembled to {obj_file}")

        cflags = args.cflags.split() if args.cflags else []
        subprocess.run(["gcc", "-c", "runtime.c", "-o", runtime_obj] + cflags, check=True)
        if args.verbose:
            print(f"[+] Compiled runtime.c to {runtime_obj}")

        ldflags = args.ldflags.split() if args.ldflags else []

        subprocess.run(["gcc", obj_file, runtime_obj, "-no-pie", "-o", executable] + ldflags, check=True)
        print(f"[✓] Linked into executable: {executable}")

        if args.run:
            print(f"[→] Running {executable}...\n")
            subprocess.run([f"./{executable}"])
            os.remove(executable)
            print(f"\n[✓] Removed executable: {executable}")

        if not args.no_clean:
            shutil.rmtree(output_dir)

    except (LexerError, ParserError) as e:
        print(f"[!] Error: {e}")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"[!] Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
