#!/bin/env python3
import sys
import os
import subprocess
import random
import string
import argparse

from core.lexer import Lexer, LexerError
from core.parser import Parser, ParserError

class CompileContext:
    def __init__(self):
        self.stack_depth = 0
        self.stack_is_string = []

    def new_label(self):
        return "sw" + "".join(random.choices(string.ascii_letters + string.digits, k=10))
    
    def add_string(self, value):
        label = self.new_label()
        if not hasattr(self, "strings"):
            self.strings = []
        self.strings.append((label, value))
        return label

def main():
    parser = argparse.ArgumentParser(description="Sweet v1.0 Compiler for x86_64 Linux (amd64)")

    parser.add_argument("source", help="Source file (.sw)")
    parser.add_argument("-o", "--output", help="Output executable name")
    parser.add_argument("--cflags", default="", help="Additional C compiler flags")
    parser.add_argument("--ldflags", default="", help="Additional linker flags")
    parser.add_argument("--asflags", default="", help="Additional NASM flags")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    input_file = args.source
    output_dir = ".build"
    os.makedirs(output_dir, exist_ok=True)

    asm_file = os.path.join(output_dir, "raw.asm")
    obj_file = os.path.join(output_dir, "raw.o")
    runtime_obj = os.path.join(output_dir, "runtime.o")

    if args.output:
        executable = args.output
    else:
        executable = "out"

    try:
        with open(input_file, "r") as f:
            src = f.read()

        lexer = Lexer(src)
        parser = Parser(lexer)
        ast = parser.parse()
        ctx = CompileContext()

        with open(asm_file, "w") as out:
            out.write(";============================================================;\n")
            out.write("; Generated by Sweet v1.0 Compiler for x86_64 Linux (amd64)  ;\n")
            out.write(";============================================================;\n")
            out.write("section .text\n")
            out.write("extern print_int\n")
            out.write("extern print_str\n")
            out.write("global sweet_main\n")
            out.write("sweet_main:\n")
            for stmt in ast:
                out.write("\n".join(stmt.compile(ctx)) + "\n")
            if ctx.stack_depth > 0:
                out.write(f"    ; Cleanup stack ({ctx.stack_depth} leftover)\n")
                out.write("    " + "\n    ".join(["pop rax"] * ctx.stack_depth) + "\n")
            out.write("    ret\n")
            out.write("section .data\n")
            if hasattr(ctx, "strings"):
                for label, value in ctx.strings:
                    raw_bytes = value.encode("utf-8").decode("unicode_escape").encode("latin1")
                    byte_values = ", ".join(str(b) for b in raw_bytes)
                    out.write(f"{label}: db {byte_values}\n")

        if args.verbose:
            print(f"[+] Assembly written to {asm_file}")

        asflags = args.asflags.split() if args.asflags else []
        subprocess.run(["nasm", "-f", "elf64", asm_file, "-o", obj_file] + asflags, check=True)
        if args.verbose:
            print(f"[+] Assembled to {obj_file}")

        cflags = args.cflags.split() if args.cflags else []
        subprocess.run(["gcc", "-c", "runtime.c", "-o", runtime_obj] + cflags, check=True)
        if args.verbose:
            print(f"[+] Compiled runtime.c to {runtime_obj}")

        ldflags = args.ldflags.split() if args.ldflags else []

        subprocess.run(["gcc", obj_file, runtime_obj, "-no-pie", "-o", executable] + ldflags, check=True)
        print(f"[âœ“] Linked into executable: {executable}")

    except (LexerError, ParserError) as e:
        print(f"[!] Error: {e}")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"[!] Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
